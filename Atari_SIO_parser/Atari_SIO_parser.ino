/*

 */
#define SECTOR_LEN    			(128u)
#define CMD_FRAME_LEN 			(4u)		  // 4 bytes + checksum byte.
#define PRINTER_FRAME_LEN		(40u)

static byte ATR_HEADER_LEN		 = 16u;           // .ATR-file has 16 byte header.
static byte sio_buffer[SECTOR_LEN + 1]	 = {0};           // extra space for checksum byte

static const byte ACK			 = 0x41;          // 'A' in ATASCII
static const byte NAK			 = 0x4E;          // 'N' in ATASCII
static const byte COMPLETE		 = 0x43;          // 'C' in ATASCII
static const byte ERR			 = 0x45;          // 'E' in ATASCII

static const unsigned int T1		 = 1u;            // T1 is generated by Atari, 650 - 950us.
static const unsigned int T2		 = 1u;            // T2 is gen'd by Arduino, can be 0 - 16ms.
static const unsigned int T3		 = 1600u;         // T3 is gen'd by Atari, 1000 - 1600ms (ACK to DATA)
static const unsigned int T4		 = 1u;            // T4 is gen'd by Arduino, 850us - 16ms.
static const unsigned int T5		 = 1u;            // T5 is gen'd by Arduino. 250us - 255s! (ACK to COMPL).

static const unsigned int SD_DISK_N_SECTORS    = 720u;    // Single Density disk's sector count
static const unsigned int DATA_FRAME_LEN_MS    = 54u;     // 129 bytes in 19200bps takes ((8b * 129B)/19200) ~ 54ms
static const unsigned int CMD_FRAME_TIMEOUT_MS = 3u;      // 5 bytes in 19200bps ~ 2.08333...ms
static const unsigned int PRINTER_FRAME_LEN_MS = 17u;     // 41 bytes in 19200bps ~ 17ms

static const byte NUM_OF_DISKS                = 0xFu;
static const byte DEVID_D1                    = 0x31u; 	  // we're D1! We consider...
static const byte DEVID_D15		      = 0x3Fu;    // 0x31...0x3F to be disk drives
static const byte DEVID_P1                    = 0x40u;

static const byte SIO_DISK_FORMAT             = 0x21u;
static const byte SIO_DISK_GET_STATUS         = 0x53u;
static const byte SIO_DISK_PUT_SECTOR         = 0x50u;
static const byte SIO_DISK_GET_SECTOR         = 0x52u;
static const byte SIO_DISK_PUT_SECTOR_VERIFY  = 0x57u;

static const byte SIO_PRINTER_PUT_LINE        = 0x57u;
static const byte SIO_PRINTER_GET_STATUS      = 0x53u;
static const byte SIO_PRINT_AUX2_NORMAL       = 0x4Eu;
static const byte SIO_PRINT_AUX2_SIDEWAYS     = 0x53u;
static const byte SIO_PRINT_AUX2_DOUBLEWIDTH  = 0x44u;

static const byte DISK_SF_INV_CMD_FRAME       = (1u << 0u);
static const byte DISK_SF_INV_DATA_FRAME      = (1u << 1u);
static const byte DISK_SF_UNSUCCESSFUL_OP     = (1u << 2u);
static const byte DISK_SF_WRITE_PROT          = (1u << 3u);
static const byte DISK_SF_MOTOR_ON            = (1u << 4u);

struct disk_status_s {
  byte flags;       // see above
  byte hw_flags;    // ??
  byte timeout_lsb; // timeout of worst operation deley in s
  byte timeout_msb;
};
typedef struct disk_status_s disk_status_t;
static disk_status_t disk_status[NUM_OF_DISKS] = {{.flags = 0x00u, .hw_flags = 0x00u, .timeout_lsb = 1u, .timeout_msb = 0x00u}}; // initialisation could be wrong

static const byte PRINTER_SF_INV_CMD_FRAME    = (1u << 0u);
static const byte PRINTER_SF_INV_DATA_FRAME   = (1u << 1u);
static const byte PRINTER_SF_INTELLIGENT_CNTR = (1u << 7u);
struct printer_status_s {
  byte flags;
  byte prev_aux2;
  byte timeout;
  byte resv;
};
typedef struct printer_status_s printer_status_t;
static printer_status_t printer_status = {.flags = 0x00u, .prev_aux2 = 0x00u, .timeout = 0x05u, .resv = 0x00u};


void setup() {
  // initialize serial:
  Serial.begin(115200u);
  Serial1.begin(19200u);

  while (!Serial) {
  }
  Serial.println("Atariino");
  Serial.println("V0.90");
  // byte number_of_disks = Serial.read();
}


void loop() {
  // nothing here - we have a reactive system based on serialEvent() function.
}


static const byte calculate_checksum(const byte *const buffer, const byte len)
{
  unsigned int chksum = 0x0000u;
  unsigned int mask_msb = 0xff00u;
  unsigned int mask_lsb = 0x00ffu;

  for (byte i = 0u; i < len; ++i) {
    chksum += (unsigned int)buffer[i];
    if(chksum & mask_msb) {
      chksum &= mask_lsb;
      ++chksum;
    }
  }
  return (byte)(chksum & mask_lsb);
}


static const bool check_cmd_frame(void)
{
  const byte frame_checksum = sio_buffer[CMD_FRAME_LEN];
  return (frame_checksum == calculate_checksum(&sio_buffer[0u], CMD_FRAME_LEN));
}


static const bool check_disk_frame(void)
{
  const byte frame_checksum = sio_buffer[SECTOR_LEN];
  return (frame_checksum == calculate_checksum(&sio_buffer[0u], SECTOR_LEN));
}


static const bool check_printer_frame(void)
{
  const byte frame_checksum = sio_buffer[PRINTER_FRAME_LEN];
  return (frame_checksum == calculate_checksum(&sio_buffer[0u], PRINTER_FRAME_LEN));
}


static const bool receive_printer_frame(void) 
{
  Serial1.setTimeout(T3 + PRINTER_FRAME_LEN_MS);
  const byte bytes_read = Serial1.readBytes(&sio_buffer[0u], PRINTER_FRAME_LEN + 1u);
  if (bytes_read == PRINTER_FRAME_LEN + 1u) {
    return true;
  } else {
    return false;
  }
}


static void print_frame(/* TODO: params */ void)
{
  Serial.write(&sio_buffer[0u], PRINTER_FRAME_LEN);
}


static const bool receive_sector(void)
{
  Serial1.setTimeout(T3 + DATA_FRAME_LEN_MS);
  const byte bytes_read = Serial1.readBytes(&sio_buffer[0u], SECTOR_LEN + 1u);
  if (bytes_read == SECTOR_LEN + 1u) {
    return true;
  } else {
    return false;
  }
}


static const bool send_frame(const byte *const frame_addr, const byte len)
{
  
  Serial1.write(frame_addr, len);
  const byte chksum = calculate_checksum(frame_addr, len);
  Serial1.write(chksum);
  // TODO: add check!
  return true;
}


static const bool send_sector(void)
{
  return send_frame(&sio_buffer[0], SECTOR_LEN);
}

static const bool send_disk_status_frame(void)
{
  return send_frame((byte*)&disk_status, sizeof(disk_status));
}

static const bool send_printer_status_frame(void)
{
  return send_frame((byte*)&printer_status, sizeof(printer_status));
}

static void send_ack(void)
{
  Serial1.write(ACK);
//  Serial.println('A');
}

static void send_nak(void)
{
  Serial1.write(NAK);
//  Serial.println('N');
}

static void send_err(void)
{
  Serial1.write(ERR);
//  Serial.println('E');
}

static void send_complete(void)
{
  Serial1.write(COMPLETE);
//  Serial.println('C');
}

static void clear_disk_status_flags(void)
{
  disk_status.flags = DISK_SF_MOTOR_ON;
}

static void clear_printer_status_flags(void)
{
  printer_status.flags = 0x00;
}

static void set_printer_aux2(const byte aux2)
{
  printer_status.prev_aux2 = aux2;
}

static const bool is_write_protected(void)
{
  return (DISK_SF_WRITE_PROT == disk_status.flags & DISK_SF_WRITE_PROT);
}

// This function is suggested by Nick Gammon (http://forum.arduino.cc/index.php?topic=151014.msg1134308#msg1134308)
static void wait_tx_hw_empty(void)
{
  while (!(UCSR1A & (1 << UDRE1))) {  // Wait for empty transmit buffer
    UCSR1A |= 1 << TXC1;             // mark transmission not complete
  }
  while (!(UCSR1A & (1 << TXC1)))
  {}                                // Wait for the transmission to complete
}


static const unsigned int auxs_to_sector(const byte aux1, const byte aux2)
{
  return (((unsigned int)aux2 << 8u) | (unsigned int)aux1);
}


static void t_delay(const unsigned int delay_ms)
{
//  Serial.print("Delay for ");
//  Serial.print(delay_ms);
//  Serial.println("ms");
  //  wait_tx_hw_empty();
  delay(delay_ms);
}

static void parse_printer_command(const byte cmdid, const byte aux1, const byte aux2) {
  t_delay(T2);
  switch (cmdid) {
    case SIO_PRINTER_GET_STATUS : // Serial.println("GET_STATUS (PRINTER)");
      send_ack();
      t_delay(T5);
      send_complete();
      send_printer_status_frame();
      clear_printer_status_flags();
      set_printer_aux2(aux2);
      break;
    case SIO_PRINTER_PUT_LINE : // Serial.println("PRINT_LINE");
      switch(aux2) {
        case 0:
        case SIO_PRINT_AUX2_NORMAL :
        case SIO_PRINT_AUX2_SIDEWAYS :
        case SIO_PRINT_AUX2_DOUBLEWIDTH :
          send_ack();
          if(receive_printer_frame(/* TODO: there should be parameter */)) {
            if(check_printer_frame(/* TODO: there should be parameter */)) {
              send_ack();
              print_frame();
              t_delay(T5);
              send_complete();
            } else {
//              Serial.println("PRINT_LINE - CHECKSUM ERROR!");
              t_delay(T4);
              send_nak();
            }
          } else {
//            Serial.println("PRINT_LINE - TIMEOUT!");
          }
          break;
        default :
//          Serial.print("PRINT_LINE - UNKNOWN AUX2 OPTION: ");
//          Serial.println(aux2);
          printer_status.flags |= PRINTER_SF_INV_CMD_FRAME;
          send_nak();
        }
      set_printer_aux2(aux2);
      break;
    default : // REFACTORE WITH DISK 
      Serial.print("UNKNOWN COMMAND_ID: ");
      Serial.print(cmdid);
      Serial.print(" AUX1: ");
      Serial.print(aux1);
      Serial.print(" AUX2: ");
      Serial.println(aux2);
      printer_status.flags |= PRINTER_SF_INV_CMD_FRAME;
      send_nak();
  }
}

static void parse_disk_command(const byte cmdid, const byte aux1, const byte aux2) {
  const unsigned int sector = auxs_to_sector(aux1, aux2) - 1u;
  switch (cmdid) {
    case SIO_DISK_FORMAT :
      t_delay(T2);
      send_ack();
      if (is_write_protected()) {
        send_err();
      } else {
        send_complete();   // TODO
      }
      break;
    case SIO_DISK_GET_STATUS :
      t_delay(T2);
      send_ack();
      t_delay(T5);
      send_complete();
      send_disk_status_frame();
      clear_disk_status_flags();
      break;
    case SIO_DISK_PUT_SECTOR :
      if (sector < SD_DISK_N_SECTORS) {
        t_delay(T2);
        send_ack();
        if (receive_sector()) {
          if(check_disk_frame()) {
            t_delay(T4);
            send_ack();
            //                          if not ok write_sector(sector, &buffer[0], SECTOR_LEN - 1);   ---> ERR! / otherwise COMPLETE
            Serial.write(DEVID_D1);
            Serial.write(cmdid);
            Serial.write(aux1);
            Serial.write(aux2);
            Serial.writeBytes(&sio_buffer[0], SECTOR_LEN);
            t_delay(5);
            if(Serial.read() == 'E') {
               send_error();
            } else {
              send_complete();
            }
          } else {
            t_delay(T4);
            send_nak();
          }
        }
      } else {
        disk_status.flags |= DISK_SF_INV_CMD_FRAME;
        t_delay(T2);
        send_nak();
      }
      break;
    case SIO_DISK_GET_SECTOR :
      if (sector < SD_DISK_N_SECTORS) {
        t_delay(T2);
        send_ack();
        t_delay(T5);
        send_complete();
        t_delay(5); // hack to test whether Atari is too slow to receive data immediately after 'C'
        Serial.write(DEVID_D1);
        Serial.write(cmdid);
        Serial.write(aux1);
        Serial.write(aux2);
        Serial.readBytes(&sio_buffer[0], SECTOR_LEN);
        send_sector();
      } else {
        disk_status.flags |= DISK_SF_INV_CMD_FRAME;
        t_delay(T2);
        send_nak();
      }
      break;
    case SIO_DISK_PUT_SECTOR_VERIFY : // Serial.print("PUT_SECTOR_VERIFY: "); Serial.println(sector);
      t_delay(T2);
      send_nak();
      break;           // TODO
    default :    // REFACTORE!
      Serial.print("UNKNOWN COMMAND_ID: ");
      Serial.print(cmdid);
      Serial.print(" AUX1: ");
      Serial.print(aux1);
      Serial.print(" AUX2: ");
      Serial.println(aux2);
      disk_status.flags |= DISK_SF_INV_CMD_FRAME;
      t_delay(T2);
      send_nak();
  }
}

static void parse_cmd_frame(void)
{
  const byte devid  = sio_buffer[0u];
  const byte cmdid  = sio_buffer[1u];
  const byte aux1   = sio_buffer[2u];
  const byte aux2   = sio_buffer[3u];
  const byte chksum = sio_buffer[4u];

  if (check_cmd_frame()) {
    switch (devid) {
      case DEVID_D1 :
        parse_disk_command(cmdid, aux1, aux2);
        break;
      case DEVID_P1 : Serial.println("PRINTER - I select you!");
        parse_printer_command(cmdid, aux1, aux2);
        break;
      default : break;
    }
  }
}

/*
  SerialEvent occurs whenever a new data comes in the
 hardware serial RX.  This routine is run between each
 time loop() runs, so using delay inside loop can delay
 response.  Multiple bytes of data may be available.
 */
void serialEvent1() {
  Serial1.setTimeout(CMD_FRAME_TIMEOUT_MS);
  byte read_bytes = Serial1.readBytes(&sio_buffer[0u], CMD_FRAME_LEN + 1u);
  if (read_bytes == CMD_FRAME_LEN + 1u) {
    parse_cmd_frame();
  } else {
    // report spurios data
#if 0
    Serial.print("DBG: Bytes received, but less than 5:");
    for (byte i = 0u; i < read_bytes; i++) {
      Serial.print(" 0x");
      Serial.print(sio_buffer[i], HEX);
    }
    Serial.println();
#endif
  }
}

